name: 'Generate Release Note'

on:
  push:
    tags:
      - 'v*' # Triggers for any tag starting with 'v' (e.g., v1.0, v2.1.3)
      - 'release-*' # Triggers for any tag starting with 'release-'
      - '1.*.*' # Triggers for any tag starting with '1.' (e.g., 1.0.0, 1.1.0)
      - '2.*.*' # Triggers for any tag starting with '2.' (e.g., 2.0.0, 2.1.0)
      - '3.*.*' # Triggers for any tag starting with '3.' (e.g., 3.0.0, 3.1.0)

permissions:
  contents: write
  pull-requests: read

jobs:
  check-for-release:
    runs-on: ubuntu-latest
    outputs:
      should-release: ${{ steps.check.outputs.should-release }}
      version: ${{ steps.check.outputs.version }}
      tag: ${{ steps.check.outputs.tag }}
      latest_tag: ${{ steps.check.outputs.latest_tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Check if release is needed
        id: check
        run: |
          echo "Tag pushed: ${{ github.ref_name }}"

          if [[ -z "${{ github.ref_name }}" ]]; then
            echo "No tag name found in the event."
            echo "should-release=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          HAVE_RELEASE=$(gh release view ${{ github.ref_name }} --json tagName --jq '.tagName' 2>/dev/null || echo "")
          if [[ -n "$HAVE_RELEASE" ]]; then
            echo "Release already exists for tag: ${{ github.ref_name }}"
            echo "should-release=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          IFS='.' read -r MAJOR MINOR PATCH <<< "${{ github.ref_name }}"

          if [[ -z "$MAJOR" || -z "$MINOR" || -z "$PATCH" ]]; then
            LATEST_TAG=null
          else
            LATEST_TAG=$(git tag --list "${MAJOR}.${MINOR}.*" | sort -V | tail -n 1)
          fi

          echo "should-release=true" >> $GITHUB_OUTPUT
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "version=${{ github.ref_name }}" >> $GITHUB_OUTPUT
          echo "tag=${{ github.ref_name }}" >> $GITHUB_OUTPUT

  create-release:
    needs: check-for-release
    if: needs.check-for-release.outputs.should-release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Generate Release Notes
        id: generate_notes
        run: |
          # Get the latest tag
          LATEST_TAG="${{ needs.check-for-release.outputs.latest_tag }}"

          if [ -z "$LATEST_TAG" ]; then
            # If no previous tag, get all commits
            COMMITS=$(git log --pretty=format:"- %s (%h)" --reverse)
          else
            # Get commits since last tag
            COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"- %s (%h)" --reverse)
          fi

          # Categorize commits
          BREAKING_CHANGES=""
          FEATURES=""
          FIXES=""
          OTHER=""

          while IFS= read -r commit; do
            if echo "$commit" | grep -qE "(BREAKING CHANGE|!:)"; then
              BREAKING_CHANGES="$BREAKING_CHANGES$commit"$'\n'
            elif echo "$commit" | grep -qE "^- feat"; then
              FEATURES="$FEATURES$commit"$'\n'
            elif echo "$commit" | grep -qE "^- fix"; then
              # Skip "Fix styling" commits
              if echo "$commit" | grep -qE "Fix styling"; then
                continue
              fi
              FIXES="$FIXES$commit"$'\n'
            else
              OTHER="$OTHER$commit"$'\n'
            fi
          done <<< "$COMMITS"

          # Build release notes
          RELEASE_NOTES="## What's Changed in ${{ needs.check-for-release.outputs.version }}"$'\n\n'

          if [ -n "$BREAKING_CHANGES" ]; then
            RELEASE_NOTES="$RELEASE_NOTES### 💥 Breaking Changes"$'\n'"$BREAKING_CHANGES"$'\n'
          fi

          if [ -n "$FEATURES" ]; then
            RELEASE_NOTES="$RELEASE_NOTES### ✨ New Features"$'\n'"$FEATURES"$'\n'
          fi

          if [ -n "$FIXES" ]; then
            RELEASE_NOTES="$RELEASE_NOTES### 🐛 Bug Fixes"$'\n'"$FIXES"$'\n'
          fi

          if [ -n "$OTHER" ]; then
            RELEASE_NOTES="$RELEASE_NOTES### 🔧 Other Changes"$'\n'"$OTHER"$'\n'
          fi

          # Add installation instructions
          RELEASE_NOTES="$RELEASE_NOTES"$'\n'"## Installation"$'\n\n'
          RELEASE_NOTES="$RELEASE_NOTES\`\`\`bash"$'\n'
          RELEASE_NOTES="$RELEASE_NOTES""composer require solution-forest/filament-field-group:^${{ needs.check-for-release.outputs.version }}"$'\n'
          RELEASE_NOTES="$RELEASE_NOTES\`\`\`"$'\n\n'

          # Output for GitHub (escape newlines)
          echo "notes<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.check-for-release.outputs.tag }}
          release_name: '${{ needs.check-for-release.outputs.version }}'
          body: ${{ steps.generate_notes.outputs.notes }}
          draft: true
          prerelease: false
